Index: py_pong.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\"\"\" py_pong - pong style game with AI\r\nPhil Jones - Feb 2021\r\nVersion 1.01 - Added AI to be beatable\r\nversion 1.02 - Improve AI to make it move the paddle to a home position in response to next shot\r\n                Also stop paddle hunting when the ball is in P1s half\r\n                Draw court\r\nVersion 1.03 - Improve game mechanics by speeding up the movement of the paddle when key is held down\r\n                This also results in a faster return from player 1 as the ball speed contains some of the paddle speed\r\n                Need to improve the AI so that it returns these faster (if it makes them) but also make it less lightly\r\n                to get there when a fast shot has come in\r\nVersion 1.04 - Work on AI improvements - react to skill or non skill of player - WIP\r\n\"\"\"\r\n\r\nimport pygame\r\nimport random\r\n\r\n# Initialise Constants\r\nBLACK = (0, 0, 0)\r\nWHITE = (200, 200, 200)\r\nRED = (255, 0, 0)\r\nBLUE = (0, 0, 255)\r\nYELLOW = (255, 0, 255)\r\nCYAN = (0, 255, 255)\r\nWINDOW_HEIGHT = 400\r\nWINDOW_WIDTH = 700\r\nMARGIN = 40\r\n\r\n\r\n# Variables\r\nstart = True\r\nfps = 60\r\nscore_player = 0\r\nscore_cpu = 0\r\nscored = 0  # score state - Ball.move method returns 1 for player score or -1 if CPU scores\r\nin_play = False\r\nplayer_paddle_default_speed = 8\r\n# Used to give a slow return from player 1\r\nslice_return_speed = 3.5\r\nai_track_non_skilled_speeds = []\r\nai_track_skilled_speeds = []\r\nai_speed_to_return = 8\r\nai_debug = True\r\n\r\n# Pygame Initialise\r\npygame.init()\r\npygame.font.init()  # you have to call this at the start,\r\nfont = pygame.font.SysFont('Courier New', 20)\r\nscreen = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))\r\nclock = pygame.time.Clock()\r\npygame.display.set_caption('py_pong V1.0.4')\r\n\r\n\r\n# Game Functions\r\ndef draw_text(text, colour, x, y):\r\n    text_surface = font.render(text, False, colour)\r\n    screen.blit(text_surface, (x, y))\r\n\r\n\r\ndef draw_court():\r\n    pygame.draw.line(screen, WHITE, (0, MARGIN), (WINDOW_WIDTH, MARGIN))\r\n    pygame.draw.line(screen, WHITE, (WINDOW_WIDTH // 2, MARGIN), (WINDOW_WIDTH // 2, WINDOW_HEIGHT))\r\n    pygame.draw.line(screen, WHITE, (0, WINDOW_HEIGHT - 1), (WINDOW_WIDTH, WINDOW_HEIGHT - 1))\r\n\r\n\r\n# Game Objects\r\nclass Paddle:\r\n    def __init__(self, x, y, colour, length):\r\n        self.x = x\r\n        self.y = y\r\n        self.length = length\r\n        self.height = 10\r\n        self.screen = screen\r\n        self.colour = colour\r\n        self.speed = player_paddle_default_speed\r\n        self.speed_ai = 4.5\r\n        self.rect = pygame.Rect(self.x, self.y, self.height, self.length)\r\n\r\n    def draw(self):\r\n        pygame.draw.rect(self.screen, self.colour, self.rect, 0)\r\n\r\n    def move(self):\r\n        key = pygame.key.get_pressed()\r\n        if key[pygame.K_UP] and self.rect.top > MARGIN:\r\n            self.rect.move_ip(0, -1 * self.speed)\r\n            # Add acceleration if paddle held down\r\n            self.speed += 1\r\n        if key[pygame.K_DOWN] and self.rect.bottom < WINDOW_HEIGHT:\r\n            self.rect.move_ip(0, self.speed)\r\n            # Add acceleration if paddle held down\r\n            self.speed += 1\r\n\r\n    def ai_move(self):\r\n        # To make the AI possible to defeat we need to mix it's response speed up\r\n        # And on occasions make it too slow to return the ball\r\n        # if the ball is in the players half randomise the CPU response speed\r\n        #print(ball.rect.centerx)\r\n        if self.rect.centery > ball.rect.bottom and self.rect.top > MARGIN:\r\n            #print(\"1\", WINDOW_WIDTH // 3, WINDOW_WIDTH // 3 - 10, ball.rect.centerx)\r\n            if ball.rect.centerx > 200 and ball.rect.centerx < 210:\r\n                self.speed_ai = self.ai_speed_mixer()\r\n            if not ball.hit_cpu_paddle and ball.rect.centerx < (WINDOW_WIDTH // 2):\r\n                #print(self.speed_ai)\r\n                self.rect.move_ip(0, -1 * self.speed_ai)\r\n            else:\r\n                self.paddle_home()\r\n        elif self.rect.centery < ball.rect.top and self.rect.bottom < WINDOW_HEIGHT:\r\n            #print(\"2\", WINDOW_WIDTH // 3, WINDOW_WIDTH // 3 - 10, ball.rect.centerx)\r\n            if ball.rect.centerx > 400 and ball.rect.centerx < 410:\r\n                self.speed_ai = self.ai_speed_mixer()\r\n            if not ball.hit_cpu_paddle and ball.rect.centerx < (WINDOW_WIDTH // 2):\r\n                #print(self.speed_ai)\r\n                self.rect.move_ip(0, self.speed_ai)\r\n            else:\r\n                self.paddle_home()\r\n\r\n    def ai_speed_mixer(self):\r\n        # These need to be tweaked to make the AI harder or easier\r\n        # Easy AI is 2.9, 5.5\r\n        # Medium AI is 3.5, 7.5\r\n        # Hard AI is 4.2, 8.0\r\n        # Make the mixer stronger or weaker depending on player 1s skilled replies\r\n        if ai_debug:\r\n            print(\"Inside ai speed mixer and the length of p1 skill list is \", len(ai_track_skilled_speeds))\r\n        if len(ai_track_skilled_speeds) > 2:\r\n            if ai_debug:\r\n                print(\"Under the cosh, forcing weak reply..\")\r\n            # Remove one of the players skill points\r\n            ai_track_skilled_speeds.clear()\r\n            return random.uniform(0.1, 0.5)\r\n        else:\r\n            return random.uniform(4.2, 8.0)\r\n\r\n    def paddle_home(self):\r\n        if self.rect.centery < WINDOW_HEIGHT // 2 - 5:\r\n            self.rect.move_ip(0, self.speed_ai)\r\n        elif self.rect.centery > WINDOW_HEIGHT // 2 + 5:\r\n            self.rect.move_ip(0, -1 * self.speed_ai)\r\n\r\n\r\nclass Ball:\r\n    def __init__(self, x, y, colour, size):\r\n        self.reset(x, y, colour, size)\r\n\r\n    def draw(self):\r\n        pygame.draw.circle(screen, self.colour, (self.rect.x + self.radius, self.rect.y + self.radius), self.radius)\r\n\r\n    def move(self):\r\n        # Check collision with walls\r\n        if self.rect.top < MARGIN:\r\n            self.speed_y *= -1\r\n        if self.rect.bottom > WINDOW_HEIGHT:\r\n            self.speed_y *= -1\r\n        # Out of bounds\r\n        if self.rect.left < 0:\r\n            self.scored = 1\r\n        if self.rect.right > WINDOW_WIDTH:\r\n            self.scored = -1\r\n\r\n        # Collides with paddles\r\n        if self.rect.colliderect(cpu_paddle.rect):\r\n            self.hit_cpu_paddle = True\r\n            self.hit_player_paddle = False\r\n            # AI can will do a slow return, after the player has made 4 good returns\r\n            if len(ai_track_skilled_speeds) > 3:\r\n                ai_track_skilled_speeds.clear()\r\n                self.speed_x = - 5  # Steady and straight\r\n                self.speed_x *= -1\r\n                if ai_debug:\r\n                    print(\"AI Returns STEADY and STRAIGHT\", len(ai_track_skilled_speeds), len(ai_track_non_skilled_speeds))\r\n            # Simple algorithm here - if the non skilled list (i.e. p1 does a lame reply twice) - send it back fast\r\n            elif len(ai_track_non_skilled_speeds) > 3:\r\n                ai_track_non_skilled_speeds.clear()\r\n                self.speed_x = - 16\r\n                self.speed_x *= -1\r\n                if ai_debug:\r\n                    print(\"AI Returns FAST - DUE TO LACK OF P1 SKILL\", len(ai_track_skilled_speeds), len(ai_track_non_skilled_speeds))\r\n            else:\r\n                self.speed_x = - self.ball_speed_mixer()\r\n                self.speed_x *= -1\r\n                if ai_debug:\r\n                    print(\"AI Returns Average random speed\", len(ai_track_skilled_speeds), len(ai_track_non_skilled_speeds))\r\n        if self.rect.colliderect(player_paddle.rect) and not self.hit_player_paddle:\r\n            self.hit_cpu_paddle = False\r\n            self.hit_player_paddle = True\r\n            # Return slowly\r\n            if player_paddle.speed == player_paddle_default_speed:\r\n                self.speed_x = slice_return_speed\r\n                ai_track_non_skilled_speeds.append(8)\r\n                if ai_debug:\r\n                    print(\"None Skilled list\", ai_track_non_skilled_speeds)\r\n            else:  # Return with top spin :-)\r\n                self.speed_x = self.ball_speed_mixer() + (player_paddle.speed / 2.5)\r\n                # Store the players return speed, i.e. skill so the AI can \"learn\" :-)\r\n                ai_track_skilled_speeds.append(player_paddle.speed)\r\n                if ai_debug:\r\n                    print(\" Skilled list\", ai_track_skilled_speeds)\r\n            self.speed_x *= -1\r\n\r\n        # Move the ball\r\n        self.rect.x += self.speed_x\r\n        self.rect.y += self.speed_y\r\n\r\n        # Handy way to manage who has scored - or if 0 we're still in play\r\n        return self.scored\r\n\r\n    def reset(self, x, y, colour, size):\r\n        self.x = x\r\n        self.y = y\r\n        self.screen = screen\r\n        self.radius = size\r\n        self.rect = pygame.Rect(self.x, self.y, self.radius * 2, self.radius * 2)\r\n        self.colour = colour\r\n        self.speed_x = -4\r\n        self.speed_y = 4\r\n        self.scored = 0\r\n        self.hit_cpu_paddle = False\r\n        self.hit_player_paddle = False\r\n        self.ai_speed_to_return = ai_speed_to_return\r\n\r\n    def ball_speed_mixer(self):\r\n        # These can be tweaked to give some un-predictable bounces\r\n        # Be nice to add a feature where the speed changes depending where about on the paddle it's hit\r\n        return random.uniform(3, 6)\r\n\r\n\r\n# Create Paddles\r\nplayer_paddle = Paddle(WINDOW_WIDTH - 40, WINDOW_HEIGHT // 2, WHITE, 80)\r\ncpu_paddle = Paddle(40, WINDOW_HEIGHT // 2, WHITE, 80)\r\n\r\n# Create Ball\r\nball = Ball(WINDOW_WIDTH - 80, WINDOW_HEIGHT // 2, RED, 6)\r\n\r\n# Main loop\r\nwhile start:\r\n    # Set Frame Rate\r\n    clock.tick(fps)\r\n\r\n    # Erase Background\r\n    screen.fill(BLACK)\r\n\r\n    # Draw Scores to Screen with HUD divider\r\n    draw_court()\r\n    draw_text(\"CPU: \" + str(score_cpu), WHITE, 20, 5)\r\n    draw_text(\"P1: \" + str(score_player), WHITE, WINDOW_WIDTH - 100, 5)\r\n\r\n    # Draw Paddles\r\n    player_paddle.draw()\r\n    cpu_paddle.draw()\r\n\r\n    if in_play and scored == 0:\r\n        # Move Paddles\r\n        player_paddle.move()\r\n        cpu_paddle.ai_move()\r\n\r\n        # Draw Ball\r\n        ball.draw()\r\n\r\n        # Move Ball\r\n        scored = ball.move()\r\n\r\n        # Check scored state\r\n        # And increment score\r\n        if scored == -1:\r\n            score_cpu += 1\r\n            # Destroy Players Skill level\r\n            ai_track_skilled_speeds.clear()\r\n            in_play = False\r\n        elif scored == 1:\r\n            score_player += 1\r\n            # Destroy Players lack of Skill level\r\n            ai_track_non_skilled_speeds.clear()\r\n            in_play = False\r\n    # We're not in play so someone scored\r\n    # Display who the point went to\r\n    else:\r\n        if scored == 1:\r\n            draw_text(\"POINT TO P1! PRESS SPACE TO SERVE..\", RED, 105, MARGIN - 20)\r\n            draw_text(\"P1: \" + str(score_player), BLUE, WINDOW_WIDTH - 100, 5)\r\n        elif scored == -1:\r\n            draw_text(\"POINT TO CPU! PRESS SPACE TO SERVE..\", RED, 100, MARGIN - 20)\r\n            draw_text(\"CPU: \" + str(score_cpu), RED, 20, 5)\r\n        elif scored == 0:\r\n            draw_text(\"PRESS SPACE TO SERVE..\", RED, 150, MARGIN - 20)\r\n\r\n    # Handle events\r\n    for event in pygame.event.get():\r\n        if event.type == pygame.QUIT:\r\n            start = False\r\n        if event.type == pygame.KEYUP:\r\n            player_paddle.speed = player_paddle_default_speed\r\n        key = pygame.key.get_pressed()\r\n        if key[pygame.K_SPACE] and not in_play:\r\n            ball.reset(WINDOW_WIDTH - 80, WINDOW_HEIGHT // 2, RED, 8)\r\n            in_play = True\r\n            scored = 0\r\n\r\n    pygame.display.update()\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/py_pong.py b/py_pong.py
--- a/py_pong.py	(revision e7b993f1c17bdfdd7d49881b8bc881e90dbbe370)
+++ b/py_pong.py	(date 1613506322294)
@@ -39,7 +39,7 @@
 ai_track_non_skilled_speeds = []
 ai_track_skilled_speeds = []
 ai_speed_to_return = 8
-ai_debug = True
+ai_debug = False
 
 # Pygame Initialise
 pygame.init()
